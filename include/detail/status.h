/******************************************************************************
 *
 * 					 	 	MPP: An MPI CPP Interface
 *
 * 					Copyright (C) 2011-2012  Simone Pellegrini
 *
 * 	This library is free software; you can redistribute it and/or modify it
 * 	under the terms of the GNU Lesser General Public License as published by the
 * 	Free Software Foundation; either version 2.1 of the License, or (at your
 * 	option) any later version.
 *
 * 	This library is distributed in the hope that it will be useful, but WITHOUT
 * 	ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * 	FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 * 	for more details.
 *
 * 	You should have received a copy of the GNU Lesser General Public License
 * 	along with this library; if not, write to the Free Software Foundation,
 * 	Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 ******************************************************************************/

#pragma once 

/** 
 * Contains the defition of the status wrapper which exists fof the sake of
 * encapsulating the MPI_Status object. 
 */

#include "detail/decls.h"

#include <memory>

namespace mpi {

struct status{

	typedef std::unique_ptr<MPI_Status> mpi_status_ptr;

	status(status&& other) :
		m_comm(other.m_comm), 
		m_status(std::move(other.m_status)),
		m_datatype(other.m_datatype) { }

	inline endpoint source();

	inline int count() const {
		int count;
		MPI_Get_count(m_status.get(), m_datatype, &count);
		return count;
	}

	inline int tag() const {
		return m_status->MPI_TAG;
	}

	inline int error() const {
		return m_status->MPI_ERROR;
	}

	/** 
	 * Friend classes declarations 
	 */
	friend class endpoint;

	template <class T>
	friend class request;

private:

	/**
	 * Avoid the generation of status objects, these objects are generated by
	 * the MPP library and it would make no sense if the user could
	 * automatically generate one of those 
	 */
	status(const MPI_Comm& com, mpi_status_ptr&& s, const MPI_Datatype& dt):
		m_comm(com), 
		m_status(std::move(s)), 
		m_datatype(dt) { }

	status(const status& other) = delete;
	status& operator=(const status& other) = delete;

	const MPI_Comm&      m_comm;
	mpi_status_ptr		 m_status;
	const MPI_Datatype   m_datatype;
};

} // end mpi namespace 

#include "detail/endpoint.h"

namespace mpi {

inline endpoint status::source() {
	return endpoint(m_status->MPI_SOURCE, m_comm);
}


} // end mpi namespace 

